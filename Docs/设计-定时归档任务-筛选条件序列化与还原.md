# 定时归档任务筛选条件序列化与还原设计方案

> **创建时间**: 2025-12-24  
> **版本**: v1.0  
> **状态**: 待实施  
> **关联模块**: ScheduledArchiveJob（定时归档任务）

---

## 1. 问题背景

### 1.1 当前设计的局限

**现状**：
- `ScheduledArchiveJob` 实体存储 `ArchiveFilterCondition` 字段（nvarchar(500)）
- 该字段保存的是生成后的 SQL WHERE 子句，例如：
  ```sql
  CreateDate < DATEADD(day, -30, GETDATE()) AND Status = 1
  ```

**问题**：
- `FilterBuilder` 组件使用结构化的 `FilterCondition` 类构建筛选条件
- 编辑任务时，无法从 SQL 字符串反向解析回表单结构
- 用户只能看到 WHERE 子句预览，但无法修改原始配置

**影响**：
- 编辑任务时筛选条件表单为空，用户体验差
- 无法微调已有筛选条件，只能重新配置
- 失去了结构化表单的优势

### 1.2 需求分析

**功能需求**：
1. 编辑任务时，筛选条件表单能完全还原原始配置
2. 支持复杂筛选条件的序列化和反序列化
3. 保持 SQL WHERE 子句用于执行归档
4. 向后兼容已有数据（没有 JSON 的旧任务）

**非功能需求**：
1. 性能：JSON 序列化/反序列化不影响归档执行性能
2. 扩展性：支持未来增加新的操作符和字段类型
3. 可维护性：前后端使用统一的 JSON 结构
4. 数据完整性：JSON 和 SQL 保持一致

---

## 2. 解决方案设计

### 2.1 方案概述

**核心思路**：**双字段存储策略**

| 字段 | 类型 | 用途 | 必填 |
|------|------|------|------|
| `ArchiveFilterCondition` | nvarchar(500) | 存储生成的 SQL WHERE 子句，用于执行归档 | ✅ 是 |
| `ArchiveFilterDefinition` | nvarchar(max) | 存储结构化 JSON，用于编辑时还原表单 | ❌ 否（兼容旧数据）|

**设计原则**：
1. ✅ **单一数据源**：创建/更新时同时生成 SQL 和 JSON
2. ✅ **SQL 优先**：归档执行只使用 `ArchiveFilterCondition`
3. ✅ **JSON 辅助**：编辑时优先从 `ArchiveFilterDefinition` 还原
4. ✅ **向后兼容**：旧数据（无 JSON）仍可查看和执行

---

### 2.2 JSON 结构设计

#### 2.2.1 数据结构定义

```json
{
  "version": "1.0",
  "filters": [
    {
      "columnName": "CreateDate",
      "columnType": "datetime",
      "operator": "RelativeDays",
      "relativeDays": -30,
      "dateRange": null,
      "dateValue": null,
      "numericValue": null,
      "numericMin": null,
      "numericMax": null,
      "stringValue": null
    },
    {
      "columnName": "Status",
      "columnType": "int",
      "operator": "Equals",
      "relativeDays": null,
      "dateRange": null,
      "dateValue": null,
      "numericValue": 1,
      "numericMin": null,
      "numericMax": null,
      "stringValue": null
    }
  ]
}
```

#### 2.2.2 字段说明

**根对象**：

| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `version` | string | 格式版本，用于未来升级 | "1.0" |
| `filters` | array | 筛选条件数组 | [...] |

**FilterCondition 对象**：

| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `columnName` | string | 字段名 | "CreateDate" |
| `columnType` | string | 字段数据类型 | "datetime", "int", "nvarchar" |
| `operator` | string | 操作符 | "RelativeDays", "Equals", "Between" |
| **日期时间值** |||
| `relativeDays` | int? | 相对天数（负数表示过去） | -30 |
| `dateRange` | DateTime?[] | 绝对日期范围 | ["2024-01-01", "2024-12-31"] |
| `dateValue` | DateTime? | 单个日期值 | "2024-12-24" |
| **数值** |||
| `numericValue` | decimal? | 数值（等于/不等于/大于/小于） | 1000 |
| `numericMin` | decimal? | 数值范围最小值 | 0 |
| `numericMax` | decimal? | 数值范围最大值 | 10000 |
| **字符串** |||
| `stringValue` | string? | 字符串值 | "Active" |

#### 2.2.3 支持的操作符

**日期时间类型**：
- `RelativeDays` - 相对天数（推荐）
- `Between` - 日期范围
- `GreaterThan` - 晚于
- `LessThan` - 早于
- `Equals` - 等于

**数值类型**：
- `Equals` - 等于
- `NotEquals` - 不等于
- `GreaterThan` - 大于
- `LessThan` - 小于
- `GreaterThanOrEqual` - 大于等于
- `LessThanOrEqual` - 小于等于
- `Between` - 范围

**字符串类型**：
- `Equals` - 等于
- `NotEquals` - 不等于
- `Contains` - 包含
- `StartsWith` - 开头是
- `EndsWith` - 结尾是

---

## 3. 技术实现方案

### 3.1 数据库层改造

#### 3.1.1 Domain 实体更新

**文件**: `src/DbArchiveTool.Domain/ScheduledArchiveJobs/ScheduledArchiveJob.cs`

**变更点**：
1. 添加新属性
2. 构造函数增加参数
3. Update 方法增加参数

```csharp
/// <summary>归档过滤条件定义(JSON格式,用于编辑时还原表单)</summary>
public string? ArchiveFilterDefinition { get; private set; }
```

#### 3.1.2 数据库迁移

**Migration 名称**: `AddArchiveFilterDefinitionToScheduledJob`

**预期 SQL**:
```sql
ALTER TABLE [ScheduledArchiveJob] 
ADD [ArchiveFilterDefinition] nvarchar(max) NULL;
```

**字段约束**：
- **类型**: nvarchar(max) - 支持大型 JSON（未来可能有复杂条件）
- **可空**: NULL - 兼容旧数据
- **索引**: 无需索引（仅编辑时使用）
- **默认值**: NULL

#### 3.1.3 EF Core 配置

**文件**: `src/DbArchiveTool.Infrastructure/Persistence/ArchiveDbContext.cs`

```csharp
modelBuilder.Entity<ScheduledArchiveJob>(builder =>
{
    // ... 现有配置 ...
    
    // 新增字段配置（可选，EF 会自动推断）
    builder.Property(x => x.ArchiveFilterDefinition)
        .HasMaxLength(null) // nvarchar(max)
        .IsRequired(false);
});
```

---

### 3.2 API 层改造

#### 3.2.1 DTO 更新

**文件**: `src/DbArchiveTool.Api/DTOs/Archives/ScheduledArchiveJobDtos.cs`

**需要修改的 DTO**：

1. **ScheduledArchiveJobDetailDto** - 详情响应
2. **CreateScheduledArchiveJobRequest** - 创建请求
3. **UpdateScheduledArchiveJobRequest** - 更新请求

**新增字段**：
```csharp
/// <summary>归档筛选条件定义(JSON格式,用于编辑时还原表单)</summary>
public string? ArchiveFilterDefinition { get; set; }
```

#### 3.2.2 Controller 映射

**文件**: `src/DbArchiveTool.Api/Controllers/V1/ScheduledArchiveJobsController.cs`

**变更点**：
- `Create` 方法：接收并保存 `ArchiveFilterDefinition`
- `Update` 方法：接收并更新 `ArchiveFilterDefinition`
- `GetById` 方法：返回 `ArchiveFilterDefinition`

**注意事项**：
- ⚠️ 后端不验证 JSON 格式（前端保证）
- ⚠️ 后端不使用 JSON 执行归档（只用 SQL）
- ✅ 后端透明传递 JSON（存储和返回）

---

### 3.3 前端改造

#### 3.3.1 Models 定义

**文件**: `src/DbArchiveTool.Web/Models/ScheduledArchiveJobModels.cs`

**新增类型**：

```csharp
/// <summary>
/// 筛选条件定义（用于 JSON 序列化）
/// </summary>
public record FilterDefinition
{
    /// <summary>格式版本</summary>
    public string Version { get; init; } = "1.0";
    
    /// <summary>筛选条件列表</summary>
    public List<FilterConditionDto> Filters { get; init; } = new();
}

/// <summary>
/// 筛选条件 DTO（与 FilterBuilder 内部结构对应）
/// </summary>
public record FilterConditionDto
{
    /// <summary>字段名</summary>
    public string? ColumnName { get; init; }
    
    /// <summary>字段数据类型</summary>
    public string? ColumnType { get; init; }
    
    /// <summary>操作符</summary>
    public string? Operator { get; init; }
    
    // 日期时间值
    public int? RelativeDays { get; init; }
    public DateTime?[]? DateRange { get; init; }
    public DateTime? DateValue { get; init; }
    
    // 数值
    public decimal? NumericValue { get; init; }
    public decimal? NumericMin { get; init; }
    public decimal? NumericMax { get; init; }
    
    // 字符串
    public string? StringValue { get; init; }
}
```

**现有 DTO 新增字段**：
- `ScheduledArchiveJobDto`
- `CreateScheduledArchiveJobRequest`
- `UpdateScheduledArchiveJobRequest`

#### 3.3.2 FilterBuilder 组件增强

**文件**: `src/DbArchiveTool.Web/Components/FilterBuilder.razor`

**新增公开方法**：

**1. 导出当前配置为 JSON**：
```csharp
/// <summary>
/// 导出当前筛选条件为 JSON 字符串
/// </summary>
/// <returns>JSON 字符串，如果没有有效条件则返回 null</returns>
public string? ExportFilterDefinition()
{
    if (_filters == null || !_filters.Any(f => !string.IsNullOrWhiteSpace(f.ColumnName)))
        return null;
        
    var definition = new FilterDefinition
    {
        Version = "1.0",
        Filters = _filters
            .Where(f => !string.IsNullOrWhiteSpace(f.ColumnName))
            .Select(f => new FilterConditionDto
            {
                ColumnName = f.ColumnName,
                ColumnType = f.ColumnType,
                Operator = f.Operator,
                RelativeDays = f.RelativeDays,
                DateRange = f.DateRange,
                DateValue = f.DateValue,
                NumericValue = f.NumericValue,
                NumericMin = f.NumericMin,
                NumericMax = f.NumericMax,
                StringValue = f.StringValue
            })
            .ToList()
    };
    
    return JsonSerializer.Serialize(definition, new JsonSerializerOptions 
    { 
        WriteIndented = false,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    });
}
```

**2. 从 JSON 加载配置**：
```csharp
/// <summary>
/// 从 JSON 字符串加载筛选条件（编辑模式）
/// </summary>
/// <param name="jsonDefinition">JSON 字符串</param>
public async Task LoadFromDefinition(string? jsonDefinition)
{
    if (string.IsNullOrWhiteSpace(jsonDefinition))
        return;
        
    try
    {
        var definition = JsonSerializer.Deserialize<FilterDefinition>(jsonDefinition);
        if (definition?.Filters == null || !definition.Filters.Any())
            return;
            
        // 清空现有条件
        _filters.Clear();
        
        // 从 JSON 恢复条件
        foreach (var dto in definition.Filters)
        {
            _filters.Add(new FilterCondition
            {
                ColumnName = dto.ColumnName,
                ColumnType = dto.ColumnType,
                Operator = dto.Operator,
                RelativeDays = dto.RelativeDays,
                DateRange = dto.DateRange,
                DateValue = dto.DateValue,
                NumericValue = dto.NumericValue,
                NumericMin = dto.NumericMin,
                NumericMax = dto.NumericMax,
                StringValue = dto.StringValue
            });
        }
        
        // 重新生成 WHERE 子句
        await UpdateWhereClause();
        StateHasChanged();
    }
    catch (JsonException ex)
    {
        Message.Error($"解析筛选条件失败: {ex.Message}");
    }
    catch (Exception ex)
    {
        Message.Error($"加载筛选条件失败: {ex.Message}");
    }
}
```

#### 3.3.3 Create.razor 页面调整

**文件**: `src/DbArchiveTool.Web/Pages/ScheduledJobs/Create.razor`

**提交时导出 JSON**：
```csharp
private async Task HandleSubmit()
{
    if (!ValidateForm())
        return;
    
    _submitting = true;
    try
    {
        // ⭐ 从 FilterBuilder 导出 JSON
        var filterDefinition = _filterBuilder?.ExportFilterDefinition();
        var primaryFilterColumn = _filterBuilder?.GetPrimaryFilterColumn();
        
        var request = new CreateScheduledArchiveJobRequest
        {
            Name = _formModel.Name!.Trim(),
            Description = string.IsNullOrWhiteSpace(_formModel.Description) 
                ? null : _formModel.Description.Trim(),
            DataSourceId = DataSourceId,
            SourceSchemaName = _formModel.SourceSchemaName ?? "dbo",
            SourceTableName = _formModel.SourceTableName!.Trim(),
            TargetSchemaName = _formModel.TargetSchemaName ?? "dbo",
            TargetTableName = _formModel.TargetTableName!.Trim(),
            ArchiveFilterColumn = primaryFilterColumn!,
            ArchiveFilterCondition = _formModel.ArchiveFilterCondition!.Trim(),
            ArchiveFilterDefinition = filterDefinition, // ⭐ 新增
            BatchSize = _formModel.BatchSize,
            MaxRowsPerExecution = _formModel.MaxRowsPerExecution,
            IntervalMinutes = _scheduleMode == "interval" 
                ? _formModel.IntervalMinutes : null,
            CronExpression = _scheduleMode == "cron" 
                ? _formModel.CronExpression?.Trim() : null,
            IsEnabled = _formModel.IsEnabled,
            MaxConsecutiveFailures = _formModel.MaxConsecutiveFailures
        };
        
        var result = await JobApi.CreateAsync(request);
        // ... 处理结果 ...
    }
    finally
    {
        _submitting = false;
    }
}
```

#### 3.3.4 Edit.razor 页面调整

**文件**: `src/DbArchiveTool.Web/Pages/ScheduledJobs/Edit.razor`

**加载时还原 JSON**：
```csharp
private async Task LoadJobAsync()
{
    _loading = true;
    try
    {
        var result = await JobApi.GetByIdAsync(JobId);
        if (result.IsSuccess && result.Value != null)
        {
            var job = result.Value;
            
            // 填充基本信息
            _formModel.Name = job.Name;
            _formModel.Description = job.Description;
            _formModel.SourceSchemaName = job.SourceSchemaName;
            _formModel.SourceTableName = job.SourceTableName;
            _formModel.TargetSchemaName = job.TargetSchemaName;
            _formModel.TargetTableName = job.TargetTableName;
            _formModel.ArchiveFilterColumn = job.ArchiveFilterColumn;
            _formModel.ArchiveFilterCondition = job.ArchiveFilterCondition;
            _formModel.BatchSize = job.BatchSize;
            _formModel.MaxRowsPerExecution = job.MaxRowsPerExecution;
            _formModel.IntervalMinutes = job.IntervalMinutes;
            _formModel.CronExpression = job.CronExpression;
            _formModel.IsEnabled = job.IsEnabled;
            _formModel.MaxConsecutiveFailures = job.MaxConsecutiveFailures;
            
            _scheduleMode = !string.IsNullOrWhiteSpace(job.CronExpression) 
                ? "cron" : "interval";
            
            // ⭐ 关键：优先从 ArchiveFilterDefinition 还原筛选条件
            if (!string.IsNullOrWhiteSpace(job.ArchiveFilterDefinition))
            {
                // 新数据：从 JSON 还原表单
                await _filterBuilder?.LoadFromDefinition(job.ArchiveFilterDefinition)!;
            }
            else
            {
                // 旧数据：只显示 WHERE 子句（只读模式）
                // FilterBuilder 会通过 WhereClause 参数显示预览
                _formModel.ArchiveFilterCondition = job.ArchiveFilterCondition;
            }
            
            SaveOriginalValues();
            StateHasChanged();
        }
        else
        {
            _jobNotFound = true;
        }
    }
    catch (Exception ex)
    {
        Message.Error($"加载任务失败: {ex.Message}");
        _jobNotFound = true;
    }
    finally
    {
        _loading = false;
    }
}
```

**提交时导出 JSON**：
```csharp
private async Task HandleSubmit()
{
    if (!ValidateForm())
        return;
    
    if (!_hasChanges)
    {
        Message.Info("没有检测到任何更改");
        return;
    }
    
    _submitting = true;
    try
    {
        // ⭐ 导出最新的筛选条件 JSON
        var filterDefinition = _filterBuilder?.ExportFilterDefinition();
        var primaryFilterColumn = _filterBuilder?.GetPrimaryFilterColumn();
        
        var request = new UpdateScheduledArchiveJobRequest
        {
            Name = _formModel.Name!.Trim(),
            Description = string.IsNullOrWhiteSpace(_formModel.Description) 
                ? null : _formModel.Description.Trim(),
            SourceSchemaName = _formModel.SourceSchemaName ?? "dbo",
            SourceTableName = _formModel.SourceTableName!.Trim(),
            TargetSchemaName = _formModel.TargetSchemaName ?? "dbo",
            TargetTableName = _formModel.TargetTableName!.Trim(),
            ArchiveFilterColumn = primaryFilterColumn!,
            ArchiveFilterCondition = _formModel.ArchiveFilterCondition!.Trim(),
            ArchiveFilterDefinition = filterDefinition, // ⭐ 新增
            BatchSize = _formModel.BatchSize,
            MaxRowsPerExecution = _formModel.MaxRowsPerExecution,
            IntervalMinutes = _scheduleMode == "interval" 
                ? _formModel.IntervalMinutes : null,
            CronExpression = _scheduleMode == "cron" 
                ? _formModel.CronExpression?.Trim() : null,
            MaxConsecutiveFailures = _formModel.MaxConsecutiveFailures
        };
        
        var result = await JobApi.UpdateAsync(JobId, request);
        // ... 处理结果 ...
    }
    finally
    {
        _submitting = false;
    }
}
```

---

## 4. 兼容性策略

### 4.1 向后兼容

**场景 1：旧任务（无 JSON）**
- **列表查看**: ✅ 正常显示（显示 WHERE 子句）
- **详情查看**: ✅ 正常显示（显示 WHERE 子句）
- **执行归档**: ✅ 正常执行（使用 SQL WHERE 子句）
- **编辑任务**: ⚠️ 筛选条件表单为空，需重新配置

**场景 2：新任务（有 JSON）**
- **所有操作**: ✅ 完全支持

### 4.2 数据迁移（可选）

**方案 A：不主动迁移**（推荐）
- 旧任务保持现状，可正常执行
- 用户编辑时自动升级（重新配置后生成 JSON）
- 优点：简单、无风险
- 缺点：旧任务编辑体验差

**方案 B：后台脚本迁移**（复杂度高）
- 尝试解析简单的 WHERE 子句生成 JSON
- 仅支持标准格式（如 `CreateDate < DATEADD(day, -30, GETDATE())`）
- 复杂条件仍需手动重新配置
- 优点：部分旧任务可自动升级
- 缺点：实现复杂，覆盖率有限

**建议**：采用方案 A，用户编辑时自然升级。

---

## 5. 测试计划

### 5.1 单元测试

**Domain 层**：
- ✅ 实体构造函数接受 `ArchiveFilterDefinition` 参数
- ✅ Update 方法更新 `ArchiveFilterDefinition`
- ✅ 字段可为 NULL

**API 层**：
- ✅ 创建任务时保存 JSON
- ✅ 更新任务时更新 JSON
- ✅ 查询任务时返回 JSON

**前端**：
- ✅ `ExportFilterDefinition` 生成正确 JSON
- ✅ `LoadFromDefinition` 正确还原条件
- ✅ JSON 序列化/反序列化正确

### 5.2 集成测试

**场景 1：创建任务**
1. 配置筛选条件（日期时间 + 数值）
2. 提交表单
3. 验证数据库同时保存 SQL 和 JSON
4. 验证 JSON 可解析且与表单一致

**场景 2：编辑任务（新数据）**
1. 打开编辑页面
2. 验证筛选条件表单正确还原
3. 修改条件
4. 提交表单
5. 验证 SQL 和 JSON 同时更新

**场景 3：编辑任务（旧数据）**
1. 打开编辑页面（旧任务，无 JSON）
2. 验证显示 WHERE 子句预览
3. 重新配置筛选条件
4. 提交表单
5. 验证生成 SQL 和 JSON

**场景 4：执行归档**
1. 执行定时任务（有 JSON 和无 JSON）
2. 验证归档使用 SQL WHERE 子句
3. 验证归档正常完成

### 5.3 端到端测试

**完整流程**：
1. 创建数据源
2. 创建定时归档任务（复杂筛选条件）
3. 查看任务列表（验证显示）
4. 查看任务详情（验证显示）
5. 编辑任务（验证还原）
6. 修改筛选条件
7. 保存任务
8. 立即执行（验证归档成功）
9. 再次编辑（验证再次还原）

---

## 6. 实施计划

### 6.1 开发阶段

**Phase 1: 后端改造**（预计 2-3 小时）
- ✅ Domain 实体添加字段
- ✅ 创建数据库迁移
- ✅ 执行迁移更新数据库
- ✅ API DTO 添加字段
- ✅ Controller 传递字段
- ✅ 单元测试

**Phase 2: 前端改造**（预计 3-4 小时）
- ✅ Models 定义 JSON 类型
- ✅ FilterBuilder 添加导出/导入方法
- ✅ Create.razor 集成导出
- ✅ Edit.razor 集成导入/导出
- ✅ 前端测试

**Phase 3: 集成测试**（预计 1-2 小时）
- ✅ 端到端测试
- ✅ 兼容性测试
- ✅ 性能测试

**Phase 4: 文档更新**（预计 1 小时）
- ✅ API 文档更新
- ✅ 开发规范更新
- ✅ 变更记录文档

**总计**：7-10 小时（1-2 个工作日）

### 6.2 任务分解

**P0（必须）**：
- [x] 创建设计方案文档
- [ ] Domain 实体更新
- [ ] 数据库迁移
- [ ] API DTO 更新
- [ ] FilterBuilder 导出/导入方法
- [ ] Edit.razor 集成
- [ ] Create.razor 集成

**P1（重要）**：
- [ ] 单元测试
- [ ] 集成测试
- [ ] 端到端测试

**P2（优化）**：
- [ ] 文档更新
- [ ] 代码注释完善
- [ ] 错误处理增强

---

## 7. 风险与缓解

### 7.1 技术风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| JSON 序列化失败 | 编辑失败 | 低 | try-catch + 友好错误提示 |
| JSON 格式不兼容 | 旧数据加载失败 | 低 | 版本号 + 向后兼容逻辑 |
| SQL 和 JSON 不一致 | 数据不一致 | 中 | 同一事务保存，后端验证 |
| 性能影响 | 创建/编辑变慢 | 低 | JSON 仅在编辑时使用，不影响执行 |

### 7.2 业务风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| 旧任务无法编辑 | 用户体验差 | 高 | 清晰提示，引导重新配置 |
| 用户不理解 JSON | 混淆 | 低 | JSON 对用户透明，只用于技术实现 |
| 数据迁移失败 | 功能不可用 | 极低 | 新字段可空，不影响现有功能 |

---

## 8. 后续扩展

### 8.1 可能的优化方向

**1. 智能解析旧数据**：
- 使用正则表达式解析标准格式的 WHERE 子句
- 自动生成 JSON（有限支持）
- 提升旧任务编辑体验

**2. 版本升级机制**：
- 支持多个 JSON 格式版本
- 自动升级旧版本格式
- 保证长期兼容性

**3. 可视化筛选条件**：
- 列表页显示筛选条件摘要
- 详情页可视化展示（表格/图标）
- 提升可读性

**4. 筛选条件模板**：
- 预定义常用筛选条件
- 一键应用模板
- 提升配置效率

### 8.2 技术演进

**短期**（1-3 个月）：
- ✅ 实现基本功能
- ✅ 稳定运行
- ✅ 收集用户反馈

**中期**（3-6 个月）：
- 优化旧数据兼容性
- 增加筛选条件模板
- 性能优化

**长期**（6-12 个月）：
- AI 辅助生成筛选条件
- 智能推荐筛选字段
- 可视化配置器

---

## 9. 总结

### 9.1 核心价值

✅ **解决痛点**：编辑任务时完全还原筛选条件表单  
✅ **向后兼容**：不影响已有功能和数据  
✅ **扩展性强**：支持未来增加新操作符  
✅ **实现简单**：前后端改动小，风险低  
✅ **性能无损**：JSON 仅在编辑时使用  

### 9.2 关键设计决策

1. **双字段策略**：SQL 用于执行，JSON 用于编辑 ✅
2. **前端序列化**：JSON 由前端生成和解析，后端透明传递 ✅
3. **可空字段**：`ArchiveFilterDefinition` 可为 NULL，兼容旧数据 ✅
4. **版本机制**：JSON 包含版本号，支持未来升级 ✅
5. **单一数据源**：创建/更新时同时生成 SQL 和 JSON ✅

### 9.3 开发原则

- ✅ 最小化修改范围
- ✅ 保持现有架构不变
- ✅ 遵循 DDD 分层原则
- ✅ 完善的错误处理
- ✅ 完整的中文注释

---

## 10. 参考资料

**相关文档**：
- [设计-定时归档任务WebUI-设计规范与操作流程.md](./设计-定时归档任务WebUI-设计规范与操作流程.md)
- [计划-定时归档任务WebUI开发实施.md](./Plans/计划-定时归档任务WebUI开发实施.md)
- [开发规范与项目结构.md](./开发规范与项目结构.md)

**技术栈**：
- .NET 8 / EF Core 8
- Blazor Server
- Ant Design Blazor
- System.Text.Json

---

**文档版本历史**：

| 版本 | 日期 | 作者 | 变更说明 |
|------|------|------|---------|
| v1.0 | 2025-12-24 | GitHub Copilot | 初始版本，完整设计方案 |

---

**审批流程**：

| 角色 | 姓名 | 审批意见 | 日期 |
|------|------|---------|------|
| 开发负责人 | - | 待审批 | - |
| 架构师 | - | 待审批 | - |
| 技术经理 | - | 待审批 | - |
