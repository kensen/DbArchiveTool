# 分区拆分功能优化说明

> 完成日期: 2025-10-17

## 问题背景

用户测试分区拆分功能后，发现以下 4 个问题需要修复：

1. **后台任务执行问题**：提交后没有自动加入执行队列
2. **第一步界面缺少上下文信息**：没有显示当前分区边界值，没有边界值验证，varchar 字段缺少提示
3. **多选验证缺失**：允许多选分区但只能拆分一个
4. **批量操作不便**：缺少智能边界建议功能

## 修复方案

### 1. 后台任务执行 ✅

**问题根源**：
- `ExecuteSplitAsync` API 返回的是 `CommandId`（需要审批的命令），而不是直接执行
- "添加分区值" 功能是同步直接执行的，用户期望拆分功能也能直接执行

**解决方案**：
- 提交后自动调用 `ApproveAsync` 接口审批命令
- 将命令加入执行队列，实现类似"添加分区值"的直接执行效果

**代码修改**：
```csharp
// 1. 执行拆分,创建命令
var executeResult = await PartitionManagementApi.ExecuteSplitAsync(DataSourceId, request);

// 2. 自动审批命令,加入执行队列
var approveResult = await PartitionManagementApi.ApproveAsync(DataSourceId, commandId, "WebUser");
```

### 2. 第一步界面增强 ✅

**新增功能**：

#### 2.1 显示当前分区边界区间
- 显示当前选中的边界值
- 显示下一个边界值（如果存在）
- 提示用户新边界值必须在区间内

**界面效果**：
```
ℹ️ 当前分区边界: 20230101 (下一个边界: 20240101)
   拆分后,此边界区间将被新边界值分割为两个分区。
   新边界值必须位于当前边界和下一个边界之间。
```

#### 2.2 边界值范围验证
- 新边界值必须 **大于** 当前边界值
- 新边界值必须 **小于** 下一个边界值（如果存在）
- 支持数值类型（int、bigint）、日期类型（date、datetime）、字符串类型的比较

**实现逻辑**：
```csharp
private bool IsBoundaryGreaterThan(string newValue, string currentValue)
{
    if (IsIntegerType || IsBigIntType)
    {
        return long.Parse(newValue) > long.Parse(currentValue);
    }
    else if (IsDateType || IsDateTimeType)
    {
        return DateTime.Parse(newValue) > DateTime.Parse(currentValue);
    }
    else
    {
        return string.Compare(newValue, currentValue, StringComparison.Ordinal) > 0;
    }
}
```

#### 2.3 varchar 字段特殊提示
对于无规律的字符串类型字段，显示警告提示：

```
⚠️ 字符串类型字段拆分限制
   对于无规律的字符串(varchar/nvarchar)字段,拆分操作可能不太适用。
   建议使用 "添加分区边界值" 功能来手动添加所需的边界值。
```

### 3. 单选验证 ✅

**修改位置**：`Partitions.razor` 的 `ShowSplitPartition()` 方法

**验证逻辑**：
```csharp
private void ShowSplitPartition()
{
    if (_selectedTable is null || !_selectedPartitionRows.Any())
    {
        Message.Warning("请先选择一个分区");
        return;
    }

    // 验证只能选择一个分区
    if (_selectedPartitionRows.Count() > 1)
    {
        Message.Warning("只能选择一个分区进行拆分操作");
        return;
    }

    // ... 打开拆分向导
}
```

### 4. 智能边界建议 ✅

**功能描述**：
- 切换到"批量生成"模式时，自动填充当前边界和下一个边界作为起始/结束值
- 用户只需要设置步长（数值类型）或粒度（日期类型）即可快速生成中间边界值

**实现效果**：

#### 数值类型（int、bigint）
```
ℹ️ 已自动填充当前边界区间作为起始/结束值,您可以调整步长来批量生成中间边界。

起始值: 20230101    (自动填充)
结束值: 20240101    (自动填充)
步长: 1000000       (用户输入)
```

生成结果：`20230101, 20231101, 20240101, ...`

#### 日期类型（date、datetime）
```
ℹ️ 已自动填充当前边界区间作为起始/结束日期,您可以选择生成粒度来批量生成中间边界。

起始日期: 2023-01-01  (自动填充)
结束日期: 2024-01-01  (自动填充)
生成粒度: 按月 / 按年  (用户选择)
```

生成结果（按月）：`2023-02-01, 2023-03-01, ..., 2023-12-01`

**实现代码**：
```csharp
private void InitializeSmartBoundaryHints()
{
    if (_currentBoundary is null) return;

    if (IsIntegerType || IsBigIntType)
    {
        _generator.StartValue = _currentBoundary.LiteralValue;
        if (_nextBoundary is not null)
        {
            _generator.EndValue = _nextBoundary.LiteralValue;
        }
    }
    else if (IsDateType || IsDateTimeType)
    {
        if (DateTime.TryParse(_currentBoundary.LiteralValue, out var currentDate))
        {
            _generator.StartDate = currentDate;
        }
        if (_nextBoundary is not null && DateTime.TryParse(_nextBoundary.LiteralValue, out var nextDate))
        {
            _generator.EndDate = nextDate;
        }
    }
}
```

### 5. 批量模式支持 ✅

**新增功能**：
- 完整实现数值类型的批量生成（`GenerateNumericBoundaries`）
- 完整实现日期类型的批量生成（`GenerateDateBoundaries`）
- 批量模式下的预览和提交逻辑
- 显示待拆分的边界值列表

**提交逻辑**：
```csharp
// 收集所有要拆分的边界值
var boundariesToSplit = _generationMode == GenerationMode.Single
    ? new[] { GetBoundaryValueForDisplay() }
    : _generatedBoundaries.OrderBy(b => b).ToArray();

var request = new SplitPartitionRequest(
    DataSourceId,
    SchemaName,
    TableName,
    boundariesToSplit,  // 支持多个边界值
    _formModel.BackupConfirmed,
    "WebUser"
);
```

## 修改文件清单

### 1. Partitions.razor
**修改内容**：
- `ShowSplitPartition()` 方法增加多选验证

### 2. PartitionSplitWizard.razor
**修改内容**：
- 增加 `_currentBoundary` 和 `_nextBoundary` 字段
- 增加类型判断属性（IsTextType、IsVarCharType 等）
- 修改 `LoadMetadataAsync()` 调用 `FindCurrentAndNextBoundaries()`
- 新增 `FindCurrentAndNextBoundaries()` 方法
- 新增 `InitializeSmartBoundaryHints()` 方法
- 新增 `IsBoundaryGreaterThan()` 和 `IsBoundaryLessThan()` 方法
- 增强 `ValidateBoundaryValue()` 的范围验证逻辑
- 实现 `GenerateNumericBoundaries()` 批量生成逻辑
- 实现 `GenerateDateBoundaries()` 批量生成逻辑
- 修改 `HandleSubmit()` 支持单个/批量提交并自动审批
- 修改 `NextStep()` 支持批量模式验证
- 界面增加当前分区边界显示
- 界面增加 varchar 字段警告提示
- 界面增加批量模式的智能提示
- 界面增加待拆分边界值列表显示
- 添加批量模式相关样式类

## 测试要点

### 单个拆分模式
1. ✅ 选择一个分区后，界面显示当前边界值和下一个边界值
2. ✅ 输入边界值时验证必须在区间内
3. ✅ varchar 字段显示警告提示
4. ✅ 提交后自动加入执行队列

### 批量拆分模式
1. ✅ 切换到批量模式时，起始/结束值自动填充
2. ✅ 数值类型：输入步长后生成中间边界值
3. ✅ 日期类型：选择粒度后生成中间边界值
4. ✅ 生成的边界值可以删除/清空
5. ✅ 提交时验证所有边界值都在区间内
6. ✅ 提交后显示边界值数量

### 边界验证
1. ✅ 边界值小于等于当前边界时提示错误
2. ✅ 边界值大于等于下一个边界时提示错误
3. ✅ 边界值已存在时提示错误
4. ✅ 支持 int、bigint、date、datetime、varchar 类型的比较

### 多选验证
1. ✅ 多选分区时提示"只能选择一个分区进行拆分"
2. ✅ 未选择分区时提示"请先选择一个分区"

## 用户体验改进

### 改进前
- ❌ 提交后只显示任务ID，不知道是否执行
- ❌ 不知道当前选择的是哪个分区边界
- ❌ 不知道边界值应该在什么范围内
- ❌ varchar 字段拆分可能不合理但没有提示
- ❌ 批量生成需要手动输入起始/结束值
- ❌ 可以多选分区但实际只能拆分一个

### 改进后
- ✅ 提交后自动加入执行队列并显示成功消息
- ✅ 清晰显示当前边界值和下一个边界值
- ✅ 实时验证输入的边界值是否在合理区间内
- ✅ varchar 字段显示警告提示，建议使用"添加边界值"功能
- ✅ 批量模式自动填充智能建议值，操作更便捷
- ✅ 多选时立即提示，避免无效操作

## 后续优化建议

1. **用户认证集成**：当前使用硬编码的 "WebUser"，应该从认证上下文获取真实用户名
2. **任务监控跳转**：提交成功后提供跳转到任务监控页面的快捷入口
3. **批量模式性能**：如果生成的边界值过多（如>100个），考虑分批提交或异步处理
4. **预览优化**：批量模式下的 SQL 预览可能很长，考虑只显示摘要或分页
5. **GUID 类型支持**：当前 GUID 类型不支持批量生成，可以考虑添加批量生成随机 GUID 的功能

## 编译状态

✅ **编译成功**（仅 5 个 AntDesign API 弃用警告，可忽略）

```
DbArchiveTool.Web 成功，出现 5 警告 (2.1 秒)
```

警告详情：
- `Checkbox.CheckedExpression` 已过时（AntDesign 组件库内部问题）
- `Selection.Key` 已过时（建议使用 RowKey，但不影响功能）

---

**开发者**: GitHub Copilot  
**审核状态**: 待用户测试验收
