# 分区管理功能设计

## 1. 背景与目标
- 在归档数据源列表中点击服务器卡片后进入分区管理界面，提供表分区的可视化管理能力。
- 支持读取 SQL Server 已有的分区函数、分区方案、目标表及分区边界信息，并可执行新增/移除等标准操作。
- 在任何分区维护流程中确保数据库安全，要求先校验前置条件、提供预览脚本与操作提示，避免数据丢失。

## 2. 领域模型规划
- 新增 PartitionConfiguration 聚合根：关联归档数据源 Id、架构名、目标表、分区函数/方案名称、分区列（类型、排序规则）、是否 Range Right、默认文件组策略、保留策略（按时间或数量）。
- 值对象：
  - PartitionBoundary：包含边界序号、边界值（支持日期、整数、自增 Id、GUID 等），负责维持边界顺序及唯一性。
  - PartitionFilegroupMapping：描述边界到文件组的映射策略，允许默认文件组或自定义文件组列表。
  - PartitionSafetyRule：封装操作前置条件（分区是否为空、锁类型、推荐执行时段等），供应用层决策。
  - PartitionCommand：表示一次分区操作（Split/Merge/Switch），包含目标、脚本、状态、审计信息。
- 仓储契约：
  - IPartitionMetadataRepository 查询分区元数据和安全快照。
  - IPartitionCommandRepository 记录审计与后台任务状态。

## 3. 应用层用例
- PartitionManagementAppService：负责读取概览、边界安全等只读操作。
- PartitionCommandAppService：处理分区命令的预览与执行，由后台任务执行核心 DDL。
  - PreviewSplitAsync / ExecuteSplitAsync：校验 Range 规则、文件组策略、生成 SPLIT 脚本。
  - PreviewMergeAsync / ExecuteMergeAsync：校验分区是否存在、是否允许合并。
  - PreviewSwitchAsync / ExecuteSwitchAsync：校验源分区是否为空或提供目标表，支持自动创建临时表。
- 所有执行操作：先返回预览脚本和风险提示，前端需用户确认（勾选“已备份/知悉风险”）才可提交执行。
- 调用流程：Web -> PartitionCommandAppService（记录审计）-> 后台任务 -> SqlPartitionCommandExecutor。

## 4. 后端执行策略
- 以后台任务执行（Queue + HostedService），避免页面关闭导致执行中断，可支持任务重试。
- 执行前检查：
  - 调用 sys.fn_my_permissions 校验 ALTER、CONTROL 权限；缺失则拒绝执行。
  - 提示用户提前备份（审计记录中写入“是否确认已备份”）。
- 执行时：所有 DDL 包裹在显式事务，使用 SET XACT_ABORT ON，失败时自动回滚。
- 执行后：更新审计日志（成功/失败、耗时、脚本摘要），保留脚本供运维回顾。

## 5. SQL 模板与命名约束
- 模板目录：Sql/Partitioning/Commands/
  - SplitRange.sql：
    `sql
    SET XACT_ABORT ON;
    SET NOCOUNT ON;
    BEGIN TRY
        BEGIN TRAN;
        ALTER PARTITION SCHEME [{PartitionScheme}] NEXT USED [{FilegroupName}];
        ALTER PARTITION FUNCTION [{PartitionFunction}]() SPLIT RANGE ({BoundaryLiteral});
        COMMIT TRAN;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRAN;
        THROW;
    END CATCH;
    `
  - MergeRange.sql：同上结构，执行 MERGE RANGE。
  - SwitchOut.sql：
    `sql
    SET XACT_ABORT ON; SET NOCOUNT ON;
    BEGIN TRY
        BEGIN TRAN;
        ALTER TABLE [{Schema}].[{SourceTable}] SWITCH PARTITION {PartitionNumber}
        TO [{Schema}].[{TargetTable}] PARTITION {TargetPartitionNumber};
        COMMIT TRAN;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRAN;
        THROW;
    END CATCH;
    `
- 命名约束：
  - 自动创建文件组：{TableName}_FG_{yyyyMMdd}。
  - 临时 staging 表：{TableName}_Stage_{yyyyMMddHHmm}。
  - 审计编号：Partition-{CommandType}-{yyyyMMddHHmmss}。
  - 所有模板参数化渲染，避免字符串拼接风险。

## 6. API 设计
- 保留现有只读控制器，并新增 PartitionCommandsController：
  - POST /api/v1/archive-data-sources/{id}/partitions/{schema}/{table}/split/preview
  - POST /.../split/execute
  - 对应 merge/switch。
  - 返回对象包含脚本、风险提示、审计 Id。
  - 提供 GET /commands/{auditId} 查询后台任务状态。

## 7. 前端界面
- 概览页：
  - Tab1：分区概览（已实现）。
  - Tab2：新增分区向导
    - 参数：起始/结束日期、间隔、或单值输入；文件组选择（已有/新建）；备份确认复选框；预览脚本列表。
  - Tab3：移除分区 / SWITCH
    - 允许选择目标分区，显示行数、安全提示；若选择 SWITCH，输入目标库/表、是否创建临时表。
  - Tab4：任务日志
    - 展示审计记录（命令、状态、执行时间、脚本下载）。
- 交互流程：预览按钮 -> 显示脚本 -> 用户确认 -> 触发执行 -> 显示任务 Id。

## 8. 安全与审计
- 强制记录每条命令：操作人、数据源、对象、脚本摘要、风险提示、确认备份标记。
- 执行失败：捕捉 SQL 异常，记录错误码/消息，提示用户通过日志查阅。
- 提供“只生成脚本”模式，运维可手动执行。

## 9. 实施步骤
1. 领域层：补充 PartitionCommand 聚合及审计实体，编写验证规则。
2. 应用层：实现 PartitionCommandAppService，集成后台任务框架和权限校验。
3. 基础设施：
   - SqlPartitionCommandExecutor 渲染模板并执行事务。
   - 审计仓储实现（EF Core 或 Dapper）。
4. API 层：新增 PartitionCommandsController，暴露预览/执行/状态接口。
5. Web 层：
   - 构建分区操作页面（Tab2/Tab3/Tab4）。
   - 调用新 API，加入备份确认与脚本预览。
6. 测试：
   - 单元测试覆盖命令校验逻辑。
  - 集成测试验证模板执行（可在测试库下运行）。
  - UI 测试（bUnit）确保交互流程。
7. 文档更新：
   - 在 Docs 中新增“操作流程”、“权限要求”、“后台任务说明”、“SQL 模板命名规则”等章节。

