# 归档配置优化方案实施文档

## 📋 变更概述

**实施日期**: 2025-11-17  
**影响范围**: `ArchiveConfiguration` 归档配置表、定时任务调度逻辑  
**优化目标**: 分离手动归档配置模板与定时归档任务,防止配置被误触发执行

---

## 🎯 问题背景

### 发现的问题

1. **定位不清晰**: `ArchiveConfiguration` 既作为"配置模板"又作为"定时任务配置",导致业务语义混乱
2. **误触发风险**: `Program.cs` 中的全局定时任务 `ExecuteAllEnabledArchiveJobsAsync()` 会读取所有 `IsEnabled=true` 的配置并执行,导致用户保存的手动归档配置被自动执行
3. **字段不完整**: 测试数据中部分配置缺少 `TargetTableName` 等关键字段

### 日志中的 6 个配置

API 启动时自动执行了以下 6 个配置:
- `dbo.A1`
- `dbo.FinishingEntryItem`
- `dbo.TaskBadResult`
- `dbo.Tasks`
- `dbo.TaskWmsInfo`
- `dbo.WmsInfo`

这些配置来自 `ArchiveConfiguration` 表,是之前手动测试时创建的配置模板,不应被定时任务自动执行。

---

## ✅ 已实施的优化

### 1. 禁用全局定时任务注册

**文件**: `src/DbArchiveTool.Api/Program.cs`

**修改内容**:
```csharp
// ⚠️ 暂时禁用全局定时归档任务
// 原因: ArchiveConfiguration 应仅作为手动归档的配置模板,不应被定时任务自动执行
// 后续将实现独立的 ScheduledArchiveJob 实体用于定时归档功能
// RecurringJob.AddOrUpdate<IArchiveJobService>(
//     "daily-archive-all",
//     "archive",
//     service => service.ExecuteAllEnabledArchiveJobsAsync(),
//     Cron.Daily(2),
//     new RecurringJobOptions { TimeZone = TimeZoneInfo.Local });
```

**效果**: API 启动时不再自动注册定时任务,不会误触发手动归档配置。

---

### 2. 添加过滤参数 `enableScheduledArchive`

**文件**: `src/DbArchiveTool.Application/Archives/ArchiveOrchestrationService.cs`

**修改内容**:
```csharp
public async Task<IEnumerable<ArchiveConfiguration>> GetArchiveConfigurationsAsync(
    Guid? dataSourceId = null,
    bool? isEnabled = null,
    bool? enableScheduledArchive = null, // ✅ 新增参数
    CancellationToken cancellationToken = default)
{
    var configs = await _configRepository.GetAllAsync(cancellationToken);

    if (dataSourceId.HasValue)
        configs = configs.Where(c => c.DataSourceId == dataSourceId.Value).ToList();

    if (isEnabled.HasValue)
        configs = configs.Where(c => c.IsEnabled == isEnabled.Value).ToList();

    // ✅ 过滤定时归档任务
    if (enableScheduledArchive.HasValue)
        configs = configs.Where(c => c.EnableScheduledArchive == enableScheduledArchive.Value).ToList();

    return configs;
}
```

**效果**: 当定时任务需要执行时,只会读取 `EnableScheduledArchive=true` 的配置。

---

### 3. 修改定时任务查询逻辑

**文件**: `src/DbArchiveTool.Application/Archives/ArchiveJobService.cs`

**修改内容**:
```csharp
// 获取所有启用的归档配置(仅包含启用了定时归档的配置)
var configs = await _orchestrationService.GetArchiveConfigurationsAsync(
    dataSourceId: null,
    isEnabled: true,
    enableScheduledArchive: true, // ✅ 仅读取启用了定时归档的配置
    CancellationToken.None);

if (configIds.Count == 0)
{
    _logger.LogInformation("没有启用定时归档的配置,跳过执行");
    // ...
}
```

**效果**: 即使未来重新启用定时任务,也不会读取手动归档配置模板。

---

## 🗂️ 数据库清理脚本

已创建清理脚本: `Sql/清理和优化-ArchiveConfiguration表.sql`

### 脚本功能

1. **查看当前配置**: 展示所有归档配置及字段完整性
2. **检查缺失字段**: 找出缺少 `TargetTableName` 的配置
3. **禁用所有配置**: 防止定时任务误触发(可选)
4. **补全目标表信息**: 自动生成 `TargetTableName = SourceTableName + '_Archive'`(可选)
5. **禁用定时归档**: 将所有配置的 `EnableScheduledArchive` 设为 0(可选)
6. **删除测试数据**: 软删除或物理删除测试配置(可选)
7. **验证结果**: 统计清理后的配置数量

### 使用方法

```sql
-- 1. 查看当前配置(默认执行)
USE DbArchiveTool;
EXEC sp_executesql N'SELECT * FROM ArchiveConfiguration WHERE IsDeleted = 0';

-- 2. 根据实际需求取消注释相应步骤并执行
-- 例如: 禁用所有定时归档
UPDATE ArchiveConfiguration
SET EnableScheduledArchive = 0, UpdatedAtUtc = GETUTCDATE(), UpdatedBy = 'System.DisableScheduled'
WHERE IsDeleted = 0 AND EnableScheduledArchive = 1;
```

---

## 🏗️ 架构优化建议

### 短期方案(已实施)

✅ **当前状态**:
- 禁用全局定时任务注册
- 添加过滤参数区分手动/定时配置
- 提供数据库清理脚本

✅ **效果**:
- 手动归档配置不会被定时任务误触发
- API 启动不再自动执行归档任务
- 保留现有数据结构,最小化代码变更

---

### 长期方案(待开发)

#### 阶段 1: 重新定义 `ArchiveConfiguration` 用途

**目标**: 仅用于手动归档的配置模板

**修改内容**:
1. 移除字段:
   - `EnableScheduledArchive`
   - `CronExpression`
   - `NextArchiveAtUtc`

2. 保留字段:
   - 配置模板基本信息(Name, Description, DataSourceId)
   - 源表和目标表信息
   - 归档方式(ArchiveMethod, IsPartitionedTable)
   - 归档参数(BatchSize, DeleteSourceDataAfterArchive, ArchiveFilterColumn)
   - 统计信息(LastExecutionTimeUtc, LastExecutionStatus, LastArchivedRowCount)

3. 新增字段(可选):
   ```csharp
   public ArchiveConfigurationType ConfigurationType { get; private set; } = ArchiveConfigurationType.Manual;
   
   public enum ArchiveConfigurationType
   {
       Manual = 1,      // 手动归档配置模板
       Scheduled = 2    // 定时归档配置(预留)
   }
   ```

**工作量**: 2-3 天
- 修改实体和数据库 Schema
- 创建 EF Core Migration
- 更新相关 API 和 UI

---

#### 阶段 2: 实现定时归档功能(独立实体)

**目标**: 创建专用的定时归档任务管理

**新增实体**: `ScheduledArchiveJob`

```csharp
/// <summary>
/// 定时归档任务配置(小批量、秒级持续归档)
/// </summary>
public sealed class ScheduledArchiveJob : AggregateRoot
{
    // 基本信息
    public string Name { get; private set; }
    public string? Description { get; private set; }
    public Guid DataSourceId { get; private set; }
    
    // 表信息
    public string SchemaName { get; private set; }
    public string TableName { get; private set; }
    public string TargetSchemaName { get; private set; }
    public string TargetTableName { get; private set; }
    
    // 归档策略
    public ArchiveMethod Method { get; private set; }
    public int BatchSize { get; private set; } = 10000;      // 每批次行数
    public int IntervalSeconds { get; private set; } = 1;     // 执行间隔(秒)
    
    // 时间过滤条件
    public string TimeFilterColumn { get; private set; }      // 如: CreateTime
    public int RetentionDays { get; private set; }            // 保留天数
    
    // 执行窗口(业务低峰期)
    public TimeOnly? StartTime { get; private set; }          // 如: 02:00
    public TimeOnly? EndTime { get; private set; }            // 如: 06:00
    
    // 资源限制
    public int MaxConcurrentJobs { get; private set; } = 1;   // 最大并发数
    public bool PauseOnHighLoad { get; private set; } = true; // 高负载时暂停
    
    // 状态和统计
    public bool IsEnabled { get; private set; }
    public DateTime? LastExecutionUtc { get; private set; }
    public long TotalArchivedRows { get; private set; }
    public double AverageRowsPerSecond { get; private set; }
    
    // Hangfire 集成
    public string? HangfireJobId { get; private set; }        // 用于取消定时任务
    
    // 领域方法
    public void Enable() { /* ... */ }
    public void Disable() { /* ... */ }
    public void UpdateStatistics(long rowsArchived, TimeSpan duration) { /* ... */ }
}
```

**业务场景**:
- 适合: 持续产生数据的普通表(日志表、历史订单表)
- 策略: 小批量(10,000行/次)、高频率(每秒/每分钟)
- 时间窗口: 仅在业务低峰期执行(如凌晨 2-6 点)
- 监控: 实时显示归档速率、剩余数据量

**实现方式**:
```csharp
// 动态注册 Hangfire 秒级定时任务
public async Task<Result> EnableScheduledArchiveAsync(Guid jobId)
{
    var job = await _scheduledArchiveRepo.GetByIdAsync(jobId);
    if (job == null) return Result.Failure("任务不存在");
    
    // 注册 Hangfire 秒级定时任务
    var hangfireJobId = RecurringJob.AddOrUpdate(
        jobId.ToString(),
        "archive-scheduled",
        () => ExecuteScheduledArchiveBatchAsync(jobId),
        $"*/{job.IntervalSeconds} * * * * *", // 每 N 秒执行一次
        new RecurringJobOptions { TimeZone = TimeZoneInfo.Local });
    
    job.Enable(hangfireJobId);
    await _scheduledArchiveRepo.UpdateAsync(job);
    
    return Result.Success();
}
```

**工作量**: 5-7 天
- 创建新实体和仓储
- 实现秒级批量归档逻辑
- 开发管理界面(CRUD + 启用/停止/监控)
- 添加资源监控和负载控制

---

## 📊 手动归档工作流优化

### 当前流程

```
用户手动归档:
  1. 选择数据源 → 选择表
  2. 配置归档参数(目标表、归档方法、过滤条件等)
  3. 预检 → 执行 → 创建 BackgroundTask(立即执行)
```

### 优化后流程

```
用户手动归档:
  1. 选择数据源 → 选择表
  2. ✅ 可选: 加载保存的配置模板(ArchiveConfiguration)
     - 自动填充上次使用的目标表、归档方法等
     - 减少重复配置,降低误操作风险
  3. 配置归档参数 → 预检
  4. 执行 → 创建 BackgroundTask(立即执行)
  5. ✅ 可选: 保存为配置模板(供下次复用)
     - 保存到 ArchiveConfiguration 表
     - 仅作为配置模板,不触发定时任务
```

### UI 改进建议

**归档配置模板列表页**:
- 显示已保存的配置模板
- 提供"复制"、"编辑"、"删除"功能
- 显示上次执行时间和结果(LastExecutionTimeUtc, LastExecutionStatus)
- 突出显示 `EnableScheduledArchive=true` 的配置(警告: 定时任务配置)

**手动归档执行页**:
- 添加"从模板加载"按钮
- 执行完成后提示"是否保存为模板?"
- 保存时默认 `EnableScheduledArchive=false`

---

## 🔧 验证步骤

### 1. 编译验证

```bash
cd f:\tmp\数据归档工具\DBManageTool
dotnet build
```

**预期结果**: 编译成功,无错误

---

### 2. 启动验证

```bash
dotnet run --project src/DbArchiveTool.Api
```

**预期日志**:
```
[10:00:57 INF] BackgroundTaskHostedService 正在启动...
[10:00:58 INF] BackgroundTaskHostedService 已启动
[10:00:58 INF] Hangfire Server started
```

**不应出现的日志**:
```
❌ Hangfire 定时归档任务开始: 执行所有启用的归档配置
❌ 找到 6 个启用的归档配置
```

---

### 3. 数据库验证

```sql
-- 查看当前配置状态
SELECT 
    Name, 
    IsEnabled, 
    EnableScheduledArchive,
    SourceTableName,
    TargetTableName
FROM ArchiveConfiguration
WHERE IsDeleted = 0;

-- 检查是否有定时任务配置
SELECT COUNT(*) AS ScheduledCount
FROM ArchiveConfiguration
WHERE IsDeleted = 0 AND EnableScheduledArchive = 1;
```

**预期结果**: `ScheduledCount = 0`(如果已执行清理脚本)

---

## 📝 后续工作清单

### 立即执行(已完成)

- [x] 禁用 `Program.cs` 中的全局定时任务注册
- [x] 添加 `enableScheduledArchive` 过滤参数
- [x] 修改 `ArchiveJobService` 查询逻辑
- [x] 创建数据库清理脚本

### 短期优化(1-2 周)

- [ ] 执行数据库清理脚本,禁用或删除测试配置
- [ ] 补全 `ArchiveConfiguration` 缺失字段(TargetTableName)
- [ ] 完善 Web UI 的"保存配置模板"功能
- [ ] 添加配置模板的复制/删除功能
- [ ] 更新用户文档,说明配置模板的使用方式

### 长期规划(2-3 个月)

- [ ] **阶段 1**: 重构 `ArchiveConfiguration` 实体
  - [ ] 移除定时任务相关字段
  - [ ] 创建 EF Core Migration
  - [ ] 更新 API 和 DTO
  - [ ] 更新 Web UI
  - [ ] 编写单元测试

- [ ] **阶段 2**: 实现 `ScheduledArchiveJob` 定时归档功能
  - [ ] 创建新实体和仓储
  - [ ] 实现秒级批量归档逻辑
  - [ ] 开发管理界面(CRUD + 监控)
  - [ ] 添加资源监控和负载控制
  - [ ] 编写集成测试

- [ ] **阶段 3**: 监控和优化
  - [ ] 添加定时任务执行统计
  - [ ] 实现告警机制(失败率过高、执行时间过长)
  - [ ] 优化批量归档性能
  - [ ] 编写运维文档

---

## 🚨 注意事项

### 1. 数据安全

- ⚠️ 清理脚本中的删除操作默认已注释,请根据实际需求取消注释
- ⚠️ 建议先在测试环境执行清理脚本,验证无误后再在生产环境执行
- ⚠️ 执行物理删除前请先备份数据库

### 2. 兼容性

- ✅ 当前修改向后兼容,不影响现有手动归档功能
- ✅ 如果未来重新启用定时任务,需确保配置的 `EnableScheduledArchive=true`
- ⚠️ 长期重构(移除字段)会影响现有数据结构,需要数据迁移

### 3. 性能影响

- ✅ 禁用定时任务后,API 启动速度不受影响
- ✅ 添加过滤参数不会影响查询性能(使用内存过滤)
- ⚠️ 定时归档功能(秒级调度)会增加 Hangfire 调度开销,需监控

---

## 📚 相关文档

- **设计文档**: `Docs/设计-归档配置优化方案.md`(本文件)
- **清理脚本**: `Sql/清理和优化-ArchiveConfiguration表.sql`
- **开发规范**: `Docs/开发规范与项目结构.md`
- **总体设计**: `Docs/总体设计文档.md`

---

## ✅ 变更确认

**修改文件**:
1. `src/DbArchiveTool.Api/Program.cs` - 禁用全局定时任务注册
2. `src/DbArchiveTool.Application/Archives/ArchiveOrchestrationService.cs` - 添加过滤参数
3. `src/DbArchiveTool.Application/Archives/ArchiveJobService.cs` - 修改查询逻辑
4. `Sql/清理和优化-ArchiveConfiguration表.sql` - 数据库清理脚本

**影响范围**:
- ✅ 不影响手动归档功能
- ✅ 不影响 BackgroundTask 执行逻辑
- ✅ API 启动不再自动执行归档任务

**回滚方案**:
- 取消注释 `Program.cs` 中的定时任务注册代码
- 移除 `enableScheduledArchive` 参数调用

---

**变更完成时间**: 2025-11-17  
**验证人员**: GitHub Copilot (AI Agent)  
**批准状态**: ✅ 待用户验证
