# 技术选型与使用指南

> **版本**: 1.0  
> *### 2.2 Blazor Server + Ant Design Blazor
- **选型原因**:
  - 单一技术栈 (C#) 降低前后端协作成本
  - SignalR 实时通信,适合归档任务进度推送
  - Ant Design Blazor 组件覆盖常见企业需求 (表格、图表、表单、流程)
  - 支持 SSR,首屏响应快速,SEO 友好
- **约束**:
  - 所有客户端交互需经服务器 -> 需要注意服务器负载规划
  - 为避免避免大规模状态同步,建议划分功能模块、分页加载
- **最佳实践**:
  - 使用 `CircuitOptions` 设置空闲超时,避免长连接耗费
  - 复用 `AntDesign` 的表单验证组件,统一交互体验
  - 主布局统一采用 Ant Design 左侧导航 + 顶部面包屑组合,保证与旧工具操作习惯一致
  - 对实时推送的长耗时任务,结合进度轮询和 SignalR 推送,保持可靠性
  - **多标签页导航**:统一采用 Ant Design 官方 `ReuseTabs` 组件,通过 `ReuseTabsService` + `[ReuseTabsPage]` 特性自动管理标签生命周期,避免手写关闭/切换事件;首页标签设置 `Closable=false`,其余页面在 `@attribute` 中定义标题与排序,保持与旧工具一致的多标签体验  
> **范围**: 新数据库归档工具整体技术选型、理由、使用规范、性能与兼容性考量

---

## 1. 技术栈概览

| 层级 | 技术选型 | 角色定位 | 选型理由 |
|------|----------|----------|----------|
| 前端 | **Blazor Server + Ant Design Blazor** | 运维控制台、配置管理、监控界面 | C# 全栈统一，组件成熟，支持实时交互 |
| WebAPI | **ASP.NET Core 8 Web API** | RESTful 接口、任务控制、对外集成 | .NET 最新 LTS、性能高、生态完善 |
| 应用层 | **.NET 8 + 原生依赖注入** | 业务编排、调度、任务协调 | 最新语言特性（Record、Span）、热重载 |
| 数据访问 | **EF Core 8 + Dapper** | 配置持久化/归档脚本执行 | 兼顾开发效率与性能，可共存互补 |
| 后台任务 | **IHostedService + Quartz.NET (可选)** | 调度、批处理、归档执行 | 原生后台任务框架，可扩展调度 |
| 底层库 | **Polly、Serilog、AutoMapper** | 重试策略、日志、对象映射 | 企业级常用库，成熟稳定 |
| 运行环境 | **.NET 8 Runtime + Kestrel** | 统一部署、容器化 | 官方推荐组合，性能与维护优异 |

---

## 2. 关键技术详解

### 2.1 .NET 8
- **优势**:
  - 原生 AOT，提升冷启动速度
  - 同步 `Span<T>`、`Memory<T>` 提高内存效率
  - HTTP/3 支持，提升网络性能
  - 长期支持 (LTS)，企业级稳定性
  - 丰富调试工具和诊断能力
- **风险与规避**:
  - 部分第三方库未完全支持 -> 选用主流库、关注兼容性公告
  - AOT 编译需适配 -> 仅在微服务端点或独立服务使用

### 2.2 Blazor Server + Ant Design Blazor
- **选型原因**:
  - 单一技术栈 (C#) 降低前后端协作成本
  - SignalR 实时通信，适合归档任务进度推送
  - Ant Design Blazor 组件覆盖常见企业需求 (表格、图表、表单、流程)
  - 支持 SSR，首屏响应快速，SEO 友好
- **约束**:
  - 所有客户端交互需经服务器 -> 需要注意服务器负载规划
  - 为避免避免大规模状态同步，建议划分功能模块、分页加载
- **最佳实践**:
  - 使用 `CircuitOptions` 设置空闲超时，避免长连接耗费
  - 复用 `AntDesign` 的表单验证组件，统一交互体验
  - 主布局统一采用 Ant Design 左侧导航 + 顶部面包屑组合，保证与旧工具操作习惯一致
  - 对实时推送的长耗时任务，结合进度轮询和 SignalR 推送，保持可靠性
  - 首页总览采用卡片化数据源看板 + 模态表单，列表与 “新增数据源” 操作均调用 `ArchiveDataSourceApiClient`，保持与后台 API 交互一致
  
#### 官方参考资料
- [Ant Design Blazor 官方文档](https://antblazor.com/zh-CN/docs/introduce)
- [Ant Design Blazor GitHub 仓库](https://github.com/ant-design-blazor/ant-design-blazor)
- [Ant Design Pro Blazor GitHub 仓库](https://github.com/ant-design-blazor/ant-design-pro-blazor)
- [Ant Design Pro Blazor 在线演示](https://pro.antblazor.com/)

### 2.3 ASP.NET Core 8 Web API
- **选型理由**:
  - Endpoint Routing 单文件快速定义 API
  - Minimal API + Controller 混合使用，兼顾灵活和规范
  - 中间件管线可裁剪，可用于统一认证、审计、异常处理
  - 官方内置 `OutputCache`、`RateLimiter`，提升系统稳定性
- **落地建议**:
  - 根据业务复杂度选择 Minimal API 或传统 Controller
  - 将认证/授权、日志、幂等中间件在 `Program.cs` 中集中配置
  - 使用 `FluentValidation` 对输入参数进行验证

### 2.4 Entity Framework Core 8
- **使用范围**: 工具自身配置、任务元数据、审计日志等 CRUD 场景
- **优势**:
  - Code First 支持迁移管理
  - LINQ 提升开发效率
  - 支持批量操作（`ExecuteUpdate`、`ExecuteDelete`）
  - 支持 `Temporal Table` (历史记录)
- **注意事项**:
  - 大批量操作应避免在 EF Core 内执行 -> 转交给 Dapper 或 BulkCopy
  - 避免无谓的 Change Tracking -> 使用 `AsNoTracking()`
  - 统一通过 Repository + Specification 模式封装访问逻辑

### 2.5 Dapper
- **使用范围**: 归档执行链路中需要运行的原生 SQL、存储过程、BCP 调用
- **优势**:
  - 轻量级、高性能
  - 几乎零抽象，对原生 SQL 友好
  - 与 EF Core 共存简单，不冲突
- **注意事项**:
  - SQL 模板统一管理，避免散落在业务代码
  - 使用参数化防止 SQL 注入
  - 对复杂返回对象利用 `MultiMapping`
  - 注意命令超时控制，避免长时间阻塞

---

## 3. 技术组合应用场景

| 场景 | 推荐技术路径 | 说明 |
|------|--------------|------|
| 数据源配置管理 | Blazor Form + EF Core | 主要 CRUD，要求一致性 |
| 分区方案设计 | Blazor 动态表格 + Dapper 元数据查询 | 需要高性能读取元数据 |
| 归档执行 | 后台 Hosted Service + Dapper + BCP | 高性能数据迁移 |
| 任务调度 | Quartz.NET / 自研调度 + EF Core | 记录调度配置，调用后台任务 |
| 实时监控 | SignalR + EF 查询缓存 | 推送实时状态，降低数据库压力 |
| 日志审计 | Serilog + EF Core (写库) + Elasticsearch (可选) | 统一日志结构，支持查询 |

---

## 4. 开发与使用规范

### 4.1 代码规范
- **异步优先**: 所有外部 IO 操作必须使用 `async/await`
- **依赖注入**: 使用 `IServiceCollection` 注册，采用 Scoped 生命周期处理 DbContext
- **命名统一**: 项目采用 PascalCase 类名和 camelCase 变量名；接口以 `I` 开头
- **配置管理**: 所有配置项进入 `appsettings.*`，并通过 `Options` 模式绑定
- **异常处理**: 应用层统一捕获异常，返回 `Result<T>` 结构；全局异常中间件记录日志

### 4.2 性能优化建议
- **Blazor**:
  - 减少不必要的 `StateHasChanged`
  - 分离大型组件，避免整体重渲染
  - 对长列表使用虚拟滚动 `Virtualize`
- **EF Core**:
  - 使用 `AsSplitQuery()` 分拆 Include 查询，避免笛卡尔积
  - Cache 元数据结果，减少重复查询
  - 定期清理 DbContext，避免长期持有
- **Dapper**:
  - 使用 `CommandDefinition` 配置超时和事务
  - 对批量执行采用 `SqlBulkCopy`

### 4.3 安全与合规
- 使用 `Microsoft.Data.SqlClient` 提供的加密传输能力
- Blazor 表单输入需进行 XSS 过滤
- 后端 API 接口需通过 JWT / Azure AD 等身份认证
- 针对敏感配置项（如密码）使用 `Azure Key Vault` 或本地密钥管理

---

## 5. 技术选型对比

| 技术 | 当前选型 | 替代方案 | 对比结论 |
|------|----------|----------|----------|
| 前端框架 | Blazor Server | React + ASP.NET Web API | Blazor 更适合纯 .NET 团队、快速迭代；React 更适合混合技术栈 |
| UI 组件库 | Ant Design Blazor | Telerik / Syncfusion | AntD 开源、生态成熟；商业组件可作为备选 |
| ORM | EF Core | Dapper Only / NHibernate | EF Core 提高开发效率；需配合 Dapper 保证性能 |
| 调度框架 | IHostedService | Hangfire / Quartz | 首期使用原生 BackgroundService，后续可按需引入第三方调度框架 |
| 日志 | Serilog | NLog / Seq | Serilog 拥有丰富 Sink，易于扩展 |

---

## 6. 部署与运维建议

1. **部署模式**
   - 单体部署：初期采用 Blazor Server + Web API 一体化部署
   - 拆分部署：当任务量增大后，将 API、任务执行服务拆分
2. **环境**
   - 开发环境：.NET 8 SDK，本地 SQL Server Express
   - 测试环境：Azure SQL / 自建 SQL Server，模拟真实环境
   - 生产环境：Windows / Linux 容器化部署
3. **监控**
   - 应用指标：使用 `Prometheus` + `Grafana`
   - 日志：Serilog 写入 Elastic Stack 或 Azure Monitor
   - 跟踪：使用 `OpenTelemetry` 收集 Trace 和 Metrics

---

## 7. 实施步骤与培训建议

1. **基础环境搭建**
   - 安装 .NET 8 SDK、Node.js（构建前端资源）
   - 搭建 SQL Server / Azure SQL 测试库
   - 安装 VS 2022 / Rider / VS Code + C# 插件

2. **团队培训计划**
   - .NET 8 新特性速成
   - Blazor + AntD Blazor 组件实践
   - EF Core 8 + Dapper 共存最佳实践
   - 归档策略与 SQL 兼容性处理

3. **迭代开发节奏**
   - Sprint 1：基础框架、数据源管理
   - Sprint 2：分区建模模块、旧工具兼容迁移
   - Sprint 3：归档执行引擎、日志监控
   - Sprint 4：调度系统、性能优化

---

## 8. 附录：常用代码模板

### 8.1 EF Core 仓储注册
```csharp
services.AddDbContext<AppDbContext>(options =>
{
    options.UseSqlServer(configuration.GetConnectionString("DefaultConnection"));
    options.EnableSensitiveDataLogging(false);
});

services.AddScoped(typeof(IRepository<>), typeof(EfRepository<>));
services.AddScoped<IDataSourceRepository, DataSourceRepository>();
```

### 8.2 Dapper 执行器注册
```csharp
services.AddScoped<ISqlExecutor, DapperSqlExecutor>();

public class DapperSqlExecutor : ISqlExecutor
{
    private readonly ILogger<DapperSqlExecutor> _logger;

    public async Task<IEnumerable<T>> QueryAsync<T>(string connectionString, string sql, object? param = null)
    {
        using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync();
        return await connection.QueryAsync<T>(sql, param, commandTimeout: 600);
    }
}
```

### 8.3 Blazor 调用 API 示例
```csharp
@inject HttpClient Http

@if (dataSources == null) {
    <Spin Tip="加载中..." />
} else {
    <Table TItem="DataSourceDto" DataSource="dataSources" />
}

@code {
    private List<DataSourceDto>? dataSources;

    protected override async Task OnInitializedAsync()
    {
        dataSources = await Http.GetFromJsonAsync<List<DataSourceDto>>("api/v1/datasources");
    }
}
```

---

*本指南为技术选型与使用建议的初版，将随着项目推进和技术验证不断迭代。欢迎团队成员在 PR 中持续补充最佳实践。*
