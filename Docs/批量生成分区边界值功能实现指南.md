# 批量生成分区边界值功能实现指南

## 功能需求
在"添加分区边界值"Drawer中添加批量生成功能,支持:
1. **数值类型**: 通过起始值、结束值、步长生成
2. **日期类型**: 通过起始日期、结束日期、粒度(按月/按年)生成
3. **文本类型**: 手动输入多个值,逐个添加到列表
4. **GUID类型**: 批量生成多个随机GUID
5. **操作流程**: 先生成值到界面预览 → 确认后批量提交

## 实现步骤

### 步骤 1: 添加生成模式选项 (PartitionBoundaryAddDrawer.razor)

在 `<Form>` 标签内,**边界值输入框之前**添加生成方式选择:

```razor
<FormItem Label="生成方式">
    <RadioGroup @bind-Value="_generationMode" ButtonStyle="@RadioButtonStyle.Solid">
        <Radio RadioButton Value="@GenerationMode.Single">单个值</Radio>
        <Radio RadioButton Value="@GenerationMode.Batch">批量生成</Radio>
    </RadioGroup>
</FormItem>
```

### 步骤 2: 修改边界值输入区域

将原来的 `<FormItem Label="* 边界值">` 及其内容包裹在条件判断中:

```razor
@if (_generationMode == GenerationMode.Single)
{
    <FormItem Label="* 边界值">
        @* 保留原来的所有输入控件代码 *@
    </FormItem>
}
else
{
    @* 批量生成UI (见步骤3) *@
}
```

### 步骤 3: 添加批量生成UI

在 `else` 块中添加:

```razor
@* 数值类型的批量生成 *@
@if (IsIntegerType || IsBigIntType)
{
    <FormItem Label="起始值" Required>
        <Input @bind-Value="_generator.StartValue" Placeholder="起始值" Style="width:100%" />
    </FormItem>
    <FormItem Label="结束值" Required>
        <Input @bind-Value="_generator.EndValue" Placeholder="结束值" Style="width:100%" />
    </FormItem>
    <FormItem Label="步长" Required>
        <Input @bind-Value="_generator.StepValue" Placeholder="步长" Style="width:100%" />
        <div class="form-tip">每次递增的数值</div>
    </FormItem>
    <FormItem>
        <Button Type="@ButtonType.Primary" OnClick="GenerateNumericBoundaries">
            <Icon Type="thunderbolt" Theme="outline" /> 生成边界值
        </Button>
    </FormItem>
}
else if (IsDateType || IsDateTimeType)
{
    <FormItem Label="起始日期" Required>
        <DatePicker @bind-Value="_generator.StartDate"
                    Placeholder="@("选择起始日期")"
                    Picker="@DatePickerType.Month"
                    Format="yyyy-MM"
                    Style="width:100%" />
    </FormItem>
    <FormItem Label="结束日期" Required>
        <DatePicker @bind-Value="_generator.EndDate"
                    Placeholder="@("选择结束日期")"
                    Picker="@DatePickerType.Month"
                    Format="yyyy-MM"
                    Style="width:100%" />
    </FormItem>
    <FormItem Label="生成粒度" Required>
        <RadioGroup @bind-Value="_generator.DateGranularity" ButtonStyle="@RadioButtonStyle.Solid">
            <Radio RadioButton Value="@("month")">按月</Radio>
            <Radio RadioButton Value="@("year")">按年</Radio>
        </RadioGroup>
        <div class="form-tip">按月: 每月1号 | 按年: 每年1月1号</div>
    </FormItem>
    <FormItem>
        <Button Type="@ButtonType.Primary" OnClick="GenerateDateBoundaries">
            <Icon Type="thunderbolt" Theme="outline" /> 生成边界值
        </Button>
    </FormItem>
}
else if (IsNVarCharType || IsVarCharType)
{
    <FormItem Label="边界值">
        <Search Placeholder="输入文本值后按回车添加" 
                EnterButton="添加" 
                @bind-Value="_generator.TextValue"
                OnSearch="AddTextBoundary"
                Style="width:100%" />
        <div class="form-tip">每次输入一个值,按回车或点击"添加"按钮</div>
    </FormItem>
}
else if (IsUniqueIdentifierType)
{
    <FormItem Label="生成数量">
        <InputNumber @bind-Value="_generator.GuidCount" 
                     Min="1" 
                     Max="100" 
                     Placeholder="生成GUID数量" 
                     Style="width:100%" />
        <div class="form-tip">批量生成随机GUID (1-100个)</div>
    </FormItem>
    <FormItem>
        <Button Type="@ButtonType.Primary" OnClick="GenerateGuids">
            <Icon Type="thunderbolt" Theme="outline" /> 生成GUID
        </Button>
    </FormItem>
}
```

### 步骤 4: 添加生成值预览区域

在批量生成UI之后,文件组输入框之前添加:

```razor
@* 生成的边界值预览 *@
@if (_generatedBoundaries.Count > 0)
{
    <Divider>待提交边界值 (@_generatedBoundaries.Count 个)</Divider>
    <div class="generated-boundaries-container">
        <div class="generated-boundaries">
            @foreach (var boundary in _generatedBoundaries.OrderBy(b => b))
            {
                <Tag Closeable OnClose="@(() => RemoveGeneratedBoundary(boundary))">@boundary</Tag>
            }
        </div>
        <div class="generated-actions">
            <Button Size="@ButtonSize.Small" OnClick="ClearGeneratedBoundaries">清空</Button>
        </div>
    </div>
}
```

### 步骤 5: 添加CSS样式

在 `<style>` 标签内添加:

```css
.generated-boundaries-container {
    border: 1px dashed #d9d9d9;
    border-radius: 4px;
    padding: 12px;
    background-color: #fafafa;
    margin-bottom: 16px;
}

.generated-boundaries {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 12px;
    min-height: 32px;
}

.generated-actions {
    display: flex;
    justify-content: flex-end;
}
```

### 步骤 6: 修改提交按钮

更新footer中的提交按钮:

```razor
<Button Type="@ButtonType.Primary"
        Loading="@_submitting"
        Disabled="@(_metadata == null || _submitting || (_generationMode == GenerationMode.Batch && _generatedBoundaries.Count == 0))"
        OnClick="@(async () => await HandleSubmit())">
    @if (_generationMode == GenerationMode.Batch && _generatedBoundaries.Count > 0)
    {
        <span>批量提交 (@_generatedBoundaries.Count 个)</span>
    }
    else
    {
        <span>提交</span>
    }
</Button>
```

### 步骤 7: 添加C#代码字段 (@code块)

在 `@code` 块中添加以下字段和类:

```csharp
// 添加字段
private BoundaryGenerator _generator = new();
private List<string> _generatedBoundaries = new();
private GenerationMode _generationMode = GenerationMode.Single;

// 添加枚举
/// <summary>边界值生成模式</summary>
private enum GenerationMode
{
    /// <summary>单个值</summary>
    Single,
    /// <summary>批量生成</summary>
    Batch
}

/// <summary>边界值生成器</summary>
private class BoundaryGenerator
{
    public string StartValue { get; set; } = string.Empty;
    public string EndValue { get; set; } = string.Empty;
    public string StepValue { get; set; } = string.Empty;
    public DateTime? StartDate { get; set; }
    public DateTime? EndDate { get; set; }
    public string DateGranularity { get; set; } = "month";
    public string TextValue { get; set; } = string.Empty;
    public int GuidCount { get; set; } = 10;
}
```

### 步骤 8: 添加生成方法

在 `@code` 块中添加:

```csharp
private void GenerateNumericBoundaries()
{
    if (string.IsNullOrWhiteSpace(_generator.StartValue) ||
        string.IsNullOrWhiteSpace(_generator.EndValue) ||
        string.IsNullOrWhiteSpace(_generator.StepValue))
    {
        Message.Warning("请填写起始值、结束值和步长");
        return;
    }

    if (!long.TryParse(_generator.StartValue, out var start) ||
        !long.TryParse(_generator.EndValue, out var end) ||
        !long.TryParse(_generator.StepValue, out var step))
    {
        Message.Warning("请输入有效的数值");
        return;
    }

    if (step <= 0)
    {
        Message.Warning("步长必须大于0");
        return;
    }

    if (end <= start)
    {
        Message.Warning("结束值必须大于起始值");
        return;
    }

    _generatedBoundaries.Clear();
    for (var current = start + step; current <= end; current += step)
    {
        var value = current.ToString();
        if (!_generatedBoundaries.Contains(value) &&
            !_existingBoundaries.Any(b => b.LiteralValue.Equals(value, StringComparison.Ordinal)))
        {
            _generatedBoundaries.Add(value);
        }
    }

    if (_generatedBoundaries.Count == 0)
    {
        Message.Warning("没有生成新的边界值,可能已存在或范围设置不合理");
    }
    else
    {
        Message.Success($"成功生成 {_generatedBoundaries.Count} 个边界值");
    }
}

private void GenerateDateBoundaries()
{
    if (!_generator.StartDate.HasValue || !_generator.EndDate.HasValue)
    {
        Message.Warning("请选择起始与结束日期");
        return;
    }

    var start = _generator.StartDate.Value;
    var end = _generator.EndDate.Value;

    if (end <= start)
    {
        Message.Warning("结束日期必须大于起始日期");
        return;
    }

    var isYearly = string.Equals(_generator.DateGranularity, "year", StringComparison.OrdinalIgnoreCase);
    _generatedBoundaries.Clear();

    var current = start;
    while (current <= end)
    {
        var boundaryDate = new DateTime(current.Year, current.Month, 1);
        var value = boundaryDate.ToString("yyyy-MM-dd");

        if (!_generatedBoundaries.Contains(value) &&
            !_existingBoundaries.Any(b => b.LiteralValue.StartsWith(value, StringComparison.Ordinal)))
        {
            _generatedBoundaries.Add(value);
        }

        current = isYearly ? current.AddYears(1) : current.AddMonths(1);
    }

    if (_generatedBoundaries.Count == 0)
    {
        Message.Warning("没有生成新的边界值,可能已存在");
    }
    else
    {
        Message.Success($"成功生成 {_generatedBoundaries.Count} 个边界值");
    }
}

private void RemoveGeneratedBoundary(string boundary)
{
    _generatedBoundaries.Remove(boundary);
}

private void ClearGeneratedBoundaries()
{
    _generatedBoundaries.Clear();
}

private void AddTextBoundary(string value)
{
    if (string.IsNullOrWhiteSpace(value))
    {
        Message.Warning("请输入文本值");
        return;
    }

    // 检查是否已存在
    if (_generatedBoundaries.Contains(value))
    {
        Message.Warning("该值已在待提交列表中");
        return;
    }

    if (_existingBoundaries.Any(b => b.LiteralValue.Equals(value, StringComparison.Ordinal)))
    {
        Message.Warning("该值已存在于分区边界中");
        return;
    }

    _generatedBoundaries.Add(value);
    _generator.TextValue = string.Empty; // 清空输入框
    Message.Success($"已添加: {value}");
}

private void GenerateGuids()
{
    if (_generator.GuidCount <= 0 || _generator.GuidCount > 100)
    {
        Message.Warning("生成数量必须在1-100之间");
        return;
    }

    var addedCount = 0;
    for (var i = 0; i < _generator.GuidCount; i++)
    {
        var guid = Guid.NewGuid().ToString();
        if (!_generatedBoundaries.Contains(guid) &&
            !_existingBoundaries.Any(b => b.LiteralValue.Equals(guid, StringComparison.OrdinalIgnoreCase)))
        {
            _generatedBoundaries.Add(guid);
            addedCount++;
        }
    }

    if (addedCount == 0)
    {
        Message.Warning("没有生成新的GUID,可能已存在");
    }
    else
    {
        Message.Success($"成功生成 {addedCount} 个GUID");
    }
}
```

### 步骤 9: 修改HandleSubmit方法

将原来的 `HandleSubmit` 方法重命名并拆分:

```csharp
private async Task HandleSubmit()
{
    _errorMessage = null;

    if (_generationMode == GenerationMode.Single)
    {
        await SubmitSingleBoundaryAsync();
    }
    else
    {
        await SubmitBatchBoundariesAsync();
    }
}

private async Task SubmitSingleBoundaryAsync()
{
    // 保留原来 HandleSubmit 的全部代码
    string? boundaryValue = null;

    if (IsIntegerType && _intValue.HasValue)
    {
        boundaryValue = _intValue.Value.ToString();
    }
    // ... 其他原有代码
}

private async Task SubmitBatchBoundariesAsync()
{
    if (_generatedBoundaries.Count == 0)
    {
        _errorMessage = "请先生成边界值";
        return;
    }

    _submitting = true;
    var successCount = 0;
    var failCount = 0;

    try
    {
        foreach (var boundaryValue in _generatedBoundaries.OrderBy(b => b))
        {
            try
            {
                var request = new AddPartitionBoundaryApiRequest(
                    SchemaName,
                    TableName,
                    boundaryValue,
                    _formModel.FilegroupName,
                    "WebUser",
                    _formModel.Notes
                );

                var result = await PartitionManagementApi.AddBoundaryAsync(DataSourceId, request);

                if (result.IsSuccess)
                {
                    successCount++;
                }
                else
                {
                    failCount++;
                }
            }
            catch
            {
                failCount++;
            }
        }

        if (successCount > 0)
        {
            Message.Success($"成功添加 {successCount} 个边界值{(failCount > 0 ? $", {failCount} 个失败" : "")}");
            await OnSuccess.InvokeAsync();
            await HandleClose();
        }
        else
        {
            _errorMessage = "批量添加失败";
        }
    }
    finally
    {
        _submitting = false;
    }
}
```

### 步骤 10: 更新HandleClose方法

在 `HandleClose` 方法中添加清理代码:

```csharp
private async Task HandleClose()
{
    _metadata = null;
    _loadedSchema = null;
    _loadedTable = null;
    _formModel = new();
    _generator = new();  // 新增
    _generatedBoundaries.Clear();  // 新增
    _generationMode = GenerationMode.Single;  // 新增
    _intValue = null;
    _bigIntValue = null;
    _dateValue = null;
    _dateTimeValue = null;
    _errorMessage = null;

    await OnClose.InvokeAsync();
}
```

## 功能特点

1. ✅ **单个/批量切换**: 通过RadioGroup切换生成模式
2. ✅ **数值类型**: 支持起始值、结束值、步长自动生成
3. ✅ **日期类型**: 支持按月/按年生成,自动取每月1号或每年1月1号
4. ✅ **文本类型**: 支持手动逐个添加,带重复检测
5. ✅ **GUID类型**: 支持批量生成随机GUID (1-100个)
6. ✅ **实时预览**: 生成后可在界面预览,支持删除单个值或清空全部
7. ✅ **去重逻辑**: 自动跳过已存在的边界值
8. ✅ **批量提交**: 按顺序逐个提交,显示成功/失败统计

## 测试步骤

### 测试1: 日期类型批量生成
1. 选择一个DateTime类型的分区表(如 dbo.TaskIQCInfo)
2. 打开"添加分区边界值"
3. 选择"批量生成"模式
4. 设置起始日期: 2024-01, 结束日期: 2025-12, 粒度: 按月
5. 点击"生成边界值" - 应生成24个月份值
6. 预览生成的值,可删除不需要的
7. 点击"批量提交"按钮
8. 验证全部提交成功

### 测试2: 数值类型批量生成
1. 选择一个int类型的分区表
2. 选择"批量生成"模式
3. 设置起始值: 1000, 结束值: 2000, 步长: 100
4. 点击"生成边界值" - 应生成10个值 (1100, 1200, ..., 2000)
5. 批量提交验证

### 测试3: 文本类型手动添加
1. 选择一个varchar/nvarchar类型的分区表
2. 选择"批量生成"模式
3. 在输入框中输入 "北京" 按回车
4. 继续输入 "上海"、"广州"、"深圳" 并逐个添加
5. 尝试重复添加 "北京" - 应提示已存在
6. 预览列表中的4个城市
7. 批量提交验证

### 测试4: GUID类型批量生成
1. 选择一个uniqueidentifier类型的分区表
2. 选择"批量生成"模式
3. 设置生成数量: 20
4. 点击"生成GUID" - 应生成20个随机GUID
5. 批量提交验证

## 注意事项

1. **日期格式**: DateTime类型统一使用 `yyyy-MM-dd` 格式
2. **步长验证**: 数值类型步长必须大于0
3. **范围验证**: 结束值必须大于起始值
4. **文本重复检测**: 
   - 检查待提交列表避免重复添加
   - 检查现有边界值避免冲突
5. **GUID数量限制**: 1-100个,避免一次生成过多
6. **去重**: 所有类型都会自动跳过已存在的边界值
7. **错误处理**: 批量提交时单个失败不影响其他值
8. **输入清空**: 文本类型添加成功后自动清空输入框,方便继续添加

## 类型支持汇总

| 数据类型 | 批量方式 | 参数说明 |
|---------|---------|---------|
| `int`, `bigint` | 自动生成 | 起始值 + 结束值 + 步长 |
| `date`, `datetime`, `datetime2` | 自动生成 | 起始日期 + 结束日期 + 粒度(月/年) |
| `varchar`, `nvarchar` | 手动添加 | 逐个输入,支持Search回车快捷添加 |
| `uniqueidentifier` | 自动生成 | 生成数量(1-100) |
